from pathlib import Path
import datetime
import os
import platform
import sys

class LocalStorage:
    @staticmethod
    def save_markdown(transcript_data: dict, output_file: str, input_file: str, language: str = None, speakers: int = 2, diarization: bool = True):
        output_path = Path(output_file)
        input_path = Path(input_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Get file metadata
        file_stats = input_path.stat()
        file_size_mb = file_stats.st_size / (1024 * 1024)  # Convert to MB
        
        # Get system information
        system_info = {
            'OS': platform.system(),
            'OS Version': platform.version(),
            'Python Version': sys.version.split()[0],
            'AWS Region': os.getenv('AWS_REGION', 'unknown')
        }
        
        # Process transcript with speaker labels
        transcript_text = ""
        
        if isinstance(transcript_data, dict) and 'results' in transcript_data:
            results = transcript_data['results']
            
            if diarization and 'speaker_labels' in results:
                segments = results['speaker_labels']['segments']
                items = results['items']
                
                current_speaker = None
                current_text = []
                
                for segment in segments:
                    speaker = segment['speaker_label']
                    start_time = float(segment['start_time'])
                    end_time = float(segment['end_time'])
                    
                    # When speaker changes, output the previous speaker's text
                    if speaker != current_speaker:
                        if current_text:
                            transcript_text += f"\n\n**{current_speaker}**: {' '.join(current_text)}"
                        current_speaker = speaker
                        current_text = []
                    
                    # Find all items that fall within this segment's time range
                    segment_items = [
                        item for item in items
                        if 'start_time' in item and
                        float(item['start_time']) >= start_time and
                        float(item['start_time']) <= end_time
                    ]
                    
                    for item in segment_items:
                        if 'alternatives' in item and item['alternatives']:
                            current_text.append(item['alternatives'][0]['content'])
                
                # Don't forget to output the last speaker's text
                if current_text:
                    transcript_text += f"\n\n**{current_speaker}**: {' '.join(current_text)}"
            else:
                # If no diarization, just use the regular transcript
                transcript_text = results['transcripts'][0]['transcript']

        # Create markdown content with extended metadata
        current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        markdown_content = f"""# Transcription

## Metadata
- Created: {current_time}
- Source File: {input_path.name}
- File Size: {file_size_mb:.2f} MB
- Duration: [Audio duration will be added in future version]
- Format: {input_path.suffix[1:].upper()}
- Language: {"Auto-detected" if not language else language}
- Speakers: {speakers}
- Diarization: {"Enabled" if diarization else "Disabled"}

## System Information
- Operating System: {system_info['OS']} ({system_info['OS Version']})
- Python Version: {system_info['Python Version']}
- AWS Region: {system_info['AWS Region']}

## Processing Information
- Transcription Service: AWS Transcribe
- Language: {"Auto-detected" if not language else language}
- Output Format: Markdown

## Content

{transcript_text}

---
Generated by AWS Transcribe Application
"""
        
        with open(output_file, 'w') as f:
            f.write(markdown_content)